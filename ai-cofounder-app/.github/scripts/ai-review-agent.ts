#!/usr/bin/env tsx
/**
 * AI Code Review Agent
 * 
 * Reviews code changes against:
 * - Requirements (from Possible Futures)
 * - Code standards
 * - Best practices
 * - Security concerns
 * 
 * Posts detailed review comments on the PR
 */

import * as fs from 'fs';
import * as path from 'path';
import { Octokit } from '@octokit/rest';

interface ReviewComment {
  path: string;
  line: number;
  side: 'LEFT' | 'RIGHT';
  body: string;
}

interface Review {
  summary: string;
  approve: boolean;
  comments: ReviewComment[];
}

async function getRequirementsForFile(filePath: string): Promise<any> {
  // Load requirements from Possible Futures database
  // This would query the SQLite DB for relevant requirements
  
  // For now, return mock requirements
  return {
    component: path.basename(filePath, path.extname(filePath)),
    standards: [
      'Must have unit tests',
      'Must handle errors',
      'Must validate inputs',
      'Must not expose secrets'
    ]
  };
}

async function reviewFile(
  filePath: string,
  diff: string
): Promise<ReviewComment[]> {
  const comments: ReviewComment[] = [];
  
  // Get requirements
  const requirements = await getRequirementsForFile(filePath);
  
  // Parse diff to get line numbers
  const lines = diff.split('\n');
  let currentLine = 0;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    if (line.startsWith('@@')) {
      // Parse line number from diff header
      const match = line.match(/@@ -\d+,?\d* \+(\d+)/);
      if (match) currentLine = parseInt(match[1]);
      continue;
    }
    
    if (line.startsWith('+')) {
      currentLine++;
      
      // Check for common issues
      if (line.includes('console.log')) {
        comments.push({
          path: filePath,
          line: currentLine,
          side: 'RIGHT',
          body: '‚ö†Ô∏è Remove console.log before merging'
        });
      }
      
      if (line.match(/password|secret|api[_-]?key/i) && !line.includes('process.env')) {
        comments.push({
          path: filePath,
          line: currentLine,
          side: 'RIGHT',
          body: 'üîí Potential secret hardcoded - should use environment variable'
        });
      }
      
      if (line.includes('any') && filePath.endsWith('.ts')) {
        comments.push({
          path: filePath,
          line: currentLine,
          side: 'RIGHT',
          body: 'üìù Avoid using `any` - use specific types for better type safety'
        });
      }
      
      if (line.length > 120) {
        comments.push({
          path: filePath,
          line: currentLine,
          side: 'RIGHT',
          body: 'üìè Line exceeds 120 characters - consider breaking into multiple lines'
        });
      }
    }
  }
  
  return comments;
}

async function reviewPR(): Promise<Review> {
  const changedFiles = process.env.CHANGED_FILES?.split(' ') || [];
  const prNumber = parseInt(process.env.PR_NUMBER || '0');
  
  const review: Review = {
    summary: '',
    approve: true,
    comments: []
  };
  
  console.log(`Reviewing ${changedFiles.length} changed files...`);
  
  for (const file of changedFiles) {
    console.log(`  Reviewing: ${file}`);
    
    // Get file diff (would use GitHub API in real implementation)
    const diff = ''; // Placeholder
    
    const fileComments = await reviewFile(file, diff);
    review.comments.push(...fileComments);
  }
  
  // Generate summary
  const issueCount = review.comments.length;
  
  review.summary = `## AI Code Review\n\n`;
  review.summary += `Reviewed ${changedFiles.length} files\n\n`;
  
  if (issueCount === 0) {
    review.summary += `‚úÖ No issues found\n`;
    review.approve = true;
  } else {
    review.summary += `Found ${issueCount} potential issues:\n\n`;
    review.comments.forEach(c => {
      review.summary += `- **${c.path}:${c.line}**: ${c.body.replace(/[\n\r]/g, ' ')}\n`;
    });
    review.approve = false;
  }
  
  review.summary += `\n---\n`;
  review.summary += `*This review was generated by the AI Code Review Agent*\n`;
  
  // Save review output
  fs.writeFileSync(
    '.github/review-output.json',
    JSON.stringify(review, null, 2)
  );
  
  return review;
}

reviewPR().then(review => {
  console.log('\nReview complete:');
  console.log(review.summary);
  
  if (!review.approve) {
    console.log('\n‚ö†Ô∏è Changes requested');
    process.exit(1);
  }
}).catch(error => {
  console.error('Review failed:', error);
  process.exit(1);
});
